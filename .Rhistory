devtools::document()
devtools::check()
library(STAT302package)
?my_lm
?my_t.test
?gapminder
?gapminder
usethis::use_test("my_lm")
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(kableExtra)
library(tinytex)
# Function: my_lm, gives a summary of the lm object in R
# Input:
# formula, a formula class object,;
# data: input data frame
# Output: a table with four columns, estimates, std_error, t_stat, and p_value
my_lm <- function(formula, data) {
X <- model.matrix(formula, data)
Y <- model.response(model.frame(formula, data))
# calculate the estimates for coefficients
estimate <- solve((t(X) %*% X)) %*% (t(X) %*% Y)
# calculate standard errors
df = nrow(data) - ncol(X)
sample_var = sum((Y - X %*% estimate) ^ 2 / df)
std_error <- sqrt(diag(sample_var * solve(t(X) %*% X)))
# calculate t statistic
t_stat <- estimate / std_error
# calculate p values
p_value <- 2 * pt(abs(t_stat), df, lower.tail = FALSE)
# create the matrix contained the output
result <- matrix(NA, nrow = ncol(X), ncol = 4)
result[, 1] <- estimate
result[, 2] <- std_error
result[, 3] <- t_stat
result[, 4] <- p_value
colnames(result) <- c("Estimate", "Std. Error", "t value", "Pr(>|t|)")
for (i in 1:ncol(X)) {
rownames(result) <- colnames(X)
}
return(result)
}
# check functions with summary()
# test_equation
test_equation <- lm(formula = mpg ~ hp * wt, data = mtcars)
# output returned from my_lm()
my_lm(test_equation, mtcars)
# output returned from summary()
summary(test_equation)
# Function: my_lm, gives a summary of the lm object in R
# Input:
# formula, a formula class object,;
# data: input data frame
# Output: a table with four columns, estimates, std_error, t_stat, and p_value
my_lm <- function(formula, data) {
X <- model.matrix(formula, data)
Y <- model.response(model.frame(formula, data))
# calculate the estimates for coefficients
estimate <- solve((t(X) %*% X)) %*% (t(X) %*% Y)
# calculate standard errors
df = nrow(data) - ncol(X)
sample_var = sum((Y - X %*% estimate) ^ 2 / df)
std_error <- sqrt(diag(sample_var * solve(t(X) %*% X)))
# calculate t statistic
t_stat <- estimate / std_error
# calculate p values
p_value <- 2 * pt(abs(t_stat), df, lower.tail = FALSE)
# create the matrix contained the output
result <- matrix(NA, nrow = ncol(X), ncol = 4)
result[, 1] <- estimate
result[, 2] <- std_error
result[, 3] <- t_stat
result[, 4] <- p_value
colnames(result) <- c("Estimate", "Std. Error", "t value", "Pr(>|t|)")
for (i in 1:ncol(X)) {
rownames(result) <- colnames(X)
}
return(result)
}
# check functions with summary()
# test_equation
test_equation <- lm(formula = mpg ~ hp * wt, data = mtcars)
# output returned from my_lm()
my_lm(test_equation, mtcars)
# output returned from summary()
summary(test_equation)$Estimate
names(summary(test_equation))
names(summary(test_equation))
summary(test_equation)$call
names(summary(test_equation))
summary(test_equation)$terms
names(summary(test_equation))
summary(test_equation)
names(summary(test_equation))
summary(test_equation)
names(summary(test_equation))
summary(test_equation)$coefficients
summary(test_equation)$coefficients
# Function: my_lm, gives a summary of the lm object in R
# Input:
# formula, a formula class object,;
# data: input data frame
# Output: a table with four columns, estimates, std_error, t_stat, and p_value
my_lm <- function(formula, data) {
X <- model.matrix(formula, data)
Y <- model.response(model.frame(formula, data))
# calculate the estimates for coefficients
estimate <- solve((t(X) %*% X)) %*% (t(X) %*% Y)
# calculate standard errors
df = nrow(data) - ncol(X)
sample_var = sum((Y - X %*% estimate) ^ 2 / df)
std_error <- sqrt(diag(sample_var * solve(t(X) %*% X)))
# calculate t statistic
t_stat <- estimate / std_error
# calculate p values
p_value <- 2 * pt(abs(t_stat), df, lower.tail = FALSE)
# create the matrix contained the output
result <- matrix(NA, nrow = ncol(X), ncol = 4)
result[, 1] <- estimate
result[, 2] <- std_error
result[, 3] <- t_stat
result[, 4] <- p_value
colnames(result) <- c("Estimate", "Std. Error", "t value", "Pr(>|t|)")
for (i in 1:ncol(X)) {
rownames(result) <- colnames(X)
}
return(result)
}
# check functions with summary()
# test_equation
test_equation <- lm(formula = mpg ~ hp * wt, data = mtcars)
# output returned from my_lm()
my_lm(test_equation, mtcars)
# output returned from summary()
summary(test_equation)
summary(test_equation)$coefficients[,1]
summary(test_equation)$coefficients
summary(test_equation)$coefficients[1,]
summary(test_equation)$coefficients[1,]
my_lm(test_equation, mtcars)[1,]
summary(test_equation)$coefficients[1,1]
my_lm(test_equation, mtcars)[1,1]
library(STAT302package)
# extract the data
demonstration_data <- my_gapminder$lifeExp
# p_value cut-off of alpha
alpha = 0.05
# Demonstrate a test of the hypothesis (Two-Sided)
result_ts <- my_t.test(demonstration_data, "two.sides", 60)
result_ts$p_val
# Demonstrate a test of the hypothesis (less)
result_less <- my_t.test(demonstration_data, "less", 60)
result_less$p_val
# Demonstrate a test of the hypothesis (greater)
result_greater <- my_t.test(demonstration_data, "greater", 60)
result_greater$p_val
# demonstrate linear regression
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
# demonstrate linear regression
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
demo_regression
# create the formula used for my_lm
variable <- c(my_gapminder$gdpPercap,my_gapminder$continent)
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
# create the formula used for my_lm
variable <- c(my_gapminder$gdpPercap,my_gapminder$continent)
demo_regression <- lm(formula = demonstration_data ~ variable, data = my_gapminder)
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
my_lm(demo_regression, data = my_gapminder)
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
my_lm(demo_regression, data = my_gapminder)
summary(demo_regression)
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
my_lm(demo_regression, data = my_gapminder)
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
output_regression <- my_lm(demo_regression, data = my_gapminder)
output_regression
# extract the estimates for gdpPercap
output_regression[2,1]
# extract the estimates for gdpPercap
est_gdp <- output_regression[2,4]
# extract the estimates for gdpPercap
est_gdp <- output_regression[2,4]
est_gdp
mod_fits <- fitted(output_regression)
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
output_regression <- my_lm(demo_regression, data = my_gapminder)
output_regression
# extract the estimates for gdpPercap
est_gdp <- output_regression[2,4]
est_gdp
mod_fits <- fitted(demo_regression)
my_df <- data.frame(actual = demo_regression, fitted = mod_fits)
mod_fits <- fitted(demo_regression)
my_df <- data.frame(actual = demonstration_data, fitted = mod_fits)
ggplot(my_df, aes(x = fitted, y = actual)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, col = "red", lty = 2) + theme_bw(base_size = 15) +
labs(x = "Fitted values", y = "Actual values", title = "Actual vs. Fitted") +
theme(plot.title = element_text(hjust = 0.5))
library(STAT302package)
library(tidyverse)
# extract the data
demonstration_data <- my_gapminder$lifeExp
# p_value cut-off of alpha
alpha = 0.05
# Demonstrate a test of the hypothesis (Two-Sided)
result_ts <- my_t.test(demonstration_data, "two.sides", 60)
result_ts$p_val
# Demonstrate a test of the hypothesis (less)
result_less <- my_t.test(demonstration_data, "less", 60)
result_less$p_val
# Demonstrate a test of the hypothesis (greater)
result_greater <- my_t.test(demonstration_data, "greater", 60)
result_greater$p_val
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap, my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
output_regression <- my_lm(demo_regression, data = my_gapminder)
output_regression
# extract the estimates for gdpPercap
est_gdp <- output_regression[2,4]
est_gdp
mod_fits <- fitted(demo_regression)
my_df <- data.frame(actual = demonstration_data, fitted = mod_fits)
ggplot(my_df, aes(x = fitted, y = actual)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, col = "red", lty = 2) + theme_bw(base_size = 15) +
labs(x = "Fitted values", y = "Actual values", title = "Actual vs. Fitted") +
theme(plot.title = element_text(hjust = 0.5))
mod_fits <- fitted(demo_regression)
my_df <- data.frame(actual = my_gapminder$lifeExp, fitted = mod_fits)
ggplot(my_df, aes(x = fitted, y = actual)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, col = "red", lty = 2) + theme_bw(base_size = 15) +
labs(x = "Fitted values", y = "Actual values", title = "Actual vs. Fitted") +
theme(plot.title = element_text(hjust = 0.5))
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap + my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
output_regression <- my_lm(demo_regression, data = my_gapminder)
output_regression
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap + my_gapminder$continent, data = my_gapminder)
summary(demo_regression)
# demonstrate the linear regression
output_regression <- my_lm(demo_regression, data = my_gapminder)
output_regression
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap + my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
output_regression <- my_lm(demo_regression, data = my_gapminder)
output_regression
# calculate y-hat
beta <- as.matrix(output_regression[,1])
alpha <- model.matrix(demonstration_data ~ my_gapminder$gdpPercap + my_gapminder$continent, data = my_gapminder)
y_hat <- alpha %*% beta
my_df <- data.frame(actual = my_gapminder$lifeExp, fitted = y_hat)
ggplot(my_df, aes(x = fitted, y = actual)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, col = "red", lty = 2) + theme_bw(base_size = 15) +
labs(x = "Fitted values", y = "Actual values", title = "Actual vs. Fitted") +
theme(plot.title = element_text(hjust = 0.5))
# calculate y-hat
beta <- as.matrix(output_regression[,1])
alpha <- model.matrix(demonstration_data ~ my_gapminder$gdpPercap + my_gapminder$continent, data = my_gapminder)
y_hat <- alpha %*% beta
my_df <- data.frame(actual = my_gapminder$lifeExp, fitted = y_hat)
ggplot(my_df, aes(x = fitted, y = actual, color = my_gapminder$continent)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, col = "red", lty = 2) +
theme_bw(base_size = 15) +
labs(x = "Fitted values", y = "Actual values", title = "Actual vs. Fitted") +
theme(plot.title = element_text(hjust = 0.5))
# calculate y-hat
beta <- as.matrix(output_regression[,1])
alpha <- model.matrix(demonstration_data ~ my_gapminder$gdpPercap + my_gapminder$continent, data = my_gapminder)
y_hat <- alpha %*% beta
# plot the graph
continent <- my_gapminder$continent
my_df <- data.frame(actual = my_gapminder$lifeExp, fitted = y_hat)
ggplot(my_df, aes(x = fitted, y = actual, color = continent)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, col = "red", lty = 2) +
theme_bw(base_size = 15) +
labs(x = "Fitted values", y = "Actual values", title = "Actual vs. Fitted") +
theme(plot.title = element_text(hjust = 0.5))
devtools::document()
rm(list = c("my_lm"))
devtools::check()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
knitr::opts_chunk$set(echo = TRUE)
# Function: my_knn_cv, return the predicted class and the corresponding cv error
# Input:
# `train`: input data frame
# `cl`: true class value of your training data
# `k_nn`: integer representing the number of neighbors
# `k_cv`: integer representing the number of folds
# Output:
# `class`: a vector of the predicted class $\hat{Y}_{i}$ for all observations
# `cv_err`: a numeric with the cross-validation misclassification error
my_knn_cv <- function(k_cv, train, cl, k_nn) {
# randomly assign observations to the training data and test data
folds <- sample(rep(1:k_cv, length = nrow(train)))
data <- data.frame("x" = train, "y" = cl, "split" = folds)
# make an empty list that stores the misclassfication error for each fold
error_list = rep(NA, k_cv)
# split training data and test data based on i
for (i in 1:k_cv) {
data_train <- data %>% filter(split != i)
data_test <- data %>% filter(split == i)
cl_test <- as.numeric(data_test$y)
pred <- knn(data_train[,1:4], data_test[,1:4], as.factor(data_train$y), k=k_nn)
# record the misclassfication rate for each fold
error_list[i] <- mean(data_test$y != pred)
}
# record the average of all misclassfication rate
cv_err <- mean(error_list)
# predict the class by using the full data
class <- knn(train, train, as.factor(data$y), k=k_nn)
return(list("class"= class,"cv_err" = cv_err))
}
library(STAT302package)
utils::browseVignettes(package = "STAT302package")
devtools::check()
devtools::checj()
devtools::check()
?my_knn_cv
?my_pow
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::document()
devtools::check()
devtools::install_github("eunicezh/STAT302package", build_vignette = TRUE, build_opts = c())
utils::browseVignettes(package = "STAT302package")
devtools::check()
devtools::check()
devtools::document()
devtools::check()
utils::browseVignettes(package = "STAT302package")
library(STAT302package)
utils::browseVignettes(package = "STAT302package")
devtools::install_github("eunicezh/STAT302package", build_vignette = TRUE, build_opts = c())
devtools::install_github(“eunicezh/STAT302package”)
devtools::install_github(eunicezh/STAT302package)
utils::browseVignettes(package = "STAT302package")
devtools::document()
devtools::check()
devtools::check()
#'
#' @name %>%
#' @rdname pipe
#' @keywords internal
#' @export
#' @importFrom magrittr %>%
#' @usage lhs \%>\% rhs
#' @param lhs A value or the magrittr placeholder.
#' @param rhs A function call using the magrittr semantics.
#' @return The result of calling `rhs(lhs)`.
NULL
#'
#' @return A list with four elements, test_stat, df, alternative, and p_value.
#' @keywords \code{inference}
#'
#' @examples
#' my_t.test(rbinom(100, size = 7, prob = 0.1), "greater", 0.9)
#' my_t.test(rbinom(100, size = 7, prob = 0.1), "less", 0.9)
#' my_t.test(rbinom(100, size = 7, prob = 0.1), "two.sided", 0.9)
#'
#' @export
my_t.test <- function(x, alternative, mu) {
estimate <- mean(x)
df <- length(x) - 1
se <- sd(x) / sqrt(length(x))
t_obs <- (estimate - mu) / se
if (alternative == "less") {
p_value <- pt(t_obs, df, lower.tail = TRUE)
} else if (alternative == "greater") {
p_value <- pt(t_obs, df, lower.tail = FALSE)
} else {
p_value <- 2 * pt(abs(t_obs), df, lower.tail = FALSE)
}
result <- list("test_stat" = t_obs,
"df" = df,
"alternative" = alternative,
"p_val" = p_value)
return(result)
}
#' @param power Numeric input for the power that \code{x} will be raised to,
#'   defaults to \code{2}.
#'
#' @return Numeric representing \code{x} raised to the power of \code{power}.
#'
#' @examples
#' my_pow(4)
#' my_pow(4, power = 3)
#'
#' @export
my_pow <- function(x, power = 2) {
return(x^power)
}
#' @param k_cv Integer representing the number of folds.
#'
#' @return a list with objects: class of speciese and CV error
#' @keywords \code{prediction}
#'
#' @examples
#' train <- na.omit(my_penguins)
#' my_knn_cv(5, train[,3:6],train[[1]], 1)
#'
#' @export
my_knn_cv <- function(k_cv, train, cl, k_nn) {
# randomly assign observations to the training data and test data
folds <- sample(rep(1:k_cv, length = nrow(train)))
data <- data.frame("x" = train, "y" = cl, "split" = folds)
# make an empty list that stores the misclassfication error for each fold
error_list = rep(NA, k_cv)
# split training data and test data based on i
for (i in 1:k_cv) {
data_train <- data %>% filter(split != i)
data_test <- data %>% filter(split == i)
cl_test <- as.numeric(data_test$y)
pred <- knn(data_train[,1:4], data_test[,1:4], as.factor(data_train$y), k=k_nn)
# record the misclassfication rate for each fold
error_list[i] <- mean(data_test$y != pred)
}
# record the average of all misclassfication rate
cv_err <- mean(error_list)
# predict the class by using the full data
class <- knn(train, train, as.factor(data$y), k=k_nn)
return(list("class"= class,"cv_err" = cv_err))
}
devtools::document()
devtools::install_github("eunicezh/STAT302package", build_vignette = TRUE, build_opts = c())
devtools::document()
devtools::document()
devtools::document()
devtools::install_github("eunicezh/STAT302package")
devtools::document()
devtools::check()
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(STAT302package)
library(tidyverse)
# extract the data
demonstration_data <- my_gapminder$lifeExp
# p_value cut-off of alpha
alpha = 0.05
# Demonstrate a test of the hypothesis (Two-Sided)
result_ts <- my_t.test(demonstration_data, "two.sides", 60)
result_ts$p_val
# Demonstrate a test of the hypothesis (less)
result_less <- my_t.test(demonstration_data, "less", 60)
result_less$p_val
# Demonstrate a test of the hypothesis (greater)
result_greater <- my_t.test(demonstration_data, "greater", 60)
result_greater$p_val
# create the formula used for my_lm
demo_regression <- lm(formula = demonstration_data ~ my_gapminder$gdpPercap + my_gapminder$continent, data = my_gapminder)
demo_regression
# demonstrate the linear regression
output_regression <- my_lm(demo_regression, data = my_gapminder)
output_regression
# extract the estimates for gdpPercap
est_gdp <- output_regression[2,4]
est_gdp
# calculate y-hat
beta <- as.matrix(output_regression[,1])
alpha <- model.matrix(demonstration_data ~ my_gapminder$gdpPercap + my_gapminder$continent, data = my_gapminder)
y_hat <- alpha %*% beta
# plot the graph
continent <- my_gapminder$continent
my_df <- data.frame(actual = my_gapminder$lifeExp, fitted = y_hat)
ggplot(my_df, aes(x = fitted, y = actual, color = continent)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, col = "red", lty = 2) +
theme_bw(base_size = 15) +
labs(x = "Fitted values", y = "Actual values", title = "Actual vs. Fitted") +
theme(plot.title = element_text(hjust = 0.5))
